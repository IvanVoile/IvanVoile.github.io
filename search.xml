<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS必备技能之Runtime（二）]]></title>
      <url>%2F2017%2F03%2F25%2FiOS%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8BRuntime%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[当向一个对象发送消息，如果方法被实现了，则直接在底层使用消息机制调动该方法，如果方法没有被实现，则响应链最前端是《iOS必备技能之Runtime（一）》中提到的动态方法解决方案，如果方法被动态添加，那么这个消息会被对象接收；如果消息不能被接收，则响应链会寻找有没有实现消息转发的方法，让别的类去接收这个消息；如果消息转发也找不到对应的方法实现，那么程序才会报错（unrecognized selector sent to instance）。 四、消息转发消息转发有两种，一种是对消息可定制的，一种是不可定制的。响应链优先响应不可定制的消息转发，如果没有实现就去响应可定制的消息转发。 简单消息转发（不可定制）简单的消息转发对转发的消息不可以修改，怎么发过来的怎么转走。1- (id)forwardingTargetForSelector:(SEL)aSelector 这个方法赋予实现这个方法的类一个“传球”的能力，如果该类没有实现这个方法，那么forwardingTargetForSelector:返回一个其他类的对象，让其他类里面的方法代为实现。如下示例，该类没有实现method方法，但是转发给OtherClass来实现这个方法。123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(method)) &#123; [[OtherClass alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 这个方法只能让我们把消息转发到另一个能处理这个消息的对象，但是无法处理消息的内容，比如参数和返回值。 完整消息转发（可定制）当前面两种方法分别返回NO和nil时，完整的消息转发forwardInvocation:就是保证程序不报“unrecognized selector sent to instance”错误的最后一关了。在完整消息转发里面，forwardInvocation:会对消息进行相应，对象会创建一个NSInvocation对象，把与尚未处理原始消息和参数一起封装起来。1- (void)forwardInvocation:(NSInvocation *)anInvocation 为了理解转发的意图和范围，想象这样一个情景：假使在一个对象里你希望能够响应negotiate方法，并且其他几个不同类的对象也能够响应这个方法（这几个类实现了negotiate方法），最先想到的方法应该是直接发送消息到这几个类里面。进一步思考，假使你的这个对象对negotiate方法的相应的实现恰恰在其他的类里面，一种实现方法就是让这个对象的类去继承那个类的方法，这样你就可以直接在在这个类里面调用negotiate方法了。但是，既然他们被分为不同的类，不属于同一继承体系，这也就意味着大部分情况下你往往不能够这么做。虽然你不能继承negotiate方法，但是你可以通过把消息直接发送给其他类的对象的方式把这个方法“借”过来。如下：123456- (id)negotiate&#123; if ( [someOtherObject respondsTo:@selector(negotiate)] ) return [someOtherObject negotiate]; return self;&#125; 但是上面这种处理方式显得有些不灵活，特别是当你想把不止一个消息传递给其他对象的时候——你必须为每一个想要借过来的方法提供和上面类似的实现。另外，如果这些消息本来就是基于runtime的，会随着新的方法和类的改变而改变其实现，那么这种处理方式就变得捉襟见肘了。forwardInvocation:就能很轻便地解决这个问题，它是这样工作的：当一个对象因为没有消息中对应方法名的方法而不能去响应消息的时候，runtime系统通知这个对象发送forwardInvocation:消息。每一个对象都从NSObject中继承得到forwardInvocation:方法，但是在NSObject的这个方法中只是简单调用了 doesNotRecognizeSelector:，这是个abstract方法（类似于C++的纯虚函数），当子类没有实现这个方法的时候，外部调用这个方法就会抛出异常。 只有当消息的接收者没能调用任何一个该类已经存在的方法的时候，forwardInvocation:方法才能够被调用来处理消息。比如，你想；要你的对象吧negotiate方法转发到其他类的对象，那么它本身就不能有negotiate方法。如果有这个方法，那么该类中就不会调用forwardInvocation:方法。 为了能够转发消息，所有的forwardInvocation:方法必须要做下面两件事： 决定消息要去哪儿 带着原始的参数向目标进行发送 消息可以用invokeWithTarget:来进行发送： 12345678- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; if ([someOtherObject respondsToSelector: [anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation];&#125; runtime系统首先会调用methodSignatureForSelector:方法来获得方法签名，方法签名记录了方法的参数和返回值的信息。12345678- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector&#123; NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; signature = [target methodSignatureForSelector:selector]; &#125; return signature;&#125; 转发的消息的返回值是要返回到原始的发送者的，所有的可以返回的类型都能被传递，包括id类型、结构体类型、双精度的浮点型数据等。 一个forwardInvocation:方法可以作为所有未被识别的消息的“分配中心”，把消息打包发送到不同的目标。或者说它可以是一个“换乘站”，把所有的消息发送到同一个目标。它可以把消息进行转化，或者只是简单地“吞掉”它，这样就会没有回应也没有报错。它还可以把几个消息集成到一个响应中。总结起来就是一句话，这个方法能做什么取决去它的实现。 转发和多继承的异同虽然Objectiv-C不支持多继承，但是使用转发来模仿继承，可以让Objective-C实现一部分多继承的特性。如下图所示，一个对象通过转发来响应消息就像是从其它类里面“借“或者说”继承“一个方法的实现一样。 在上图中，Warrior类把negotiate方法转发到Diplomat类的实例中，就像是Warrior类在实现negotiate方法一样，它会对negotiate方法做出响应。所以，转发和多继承有很多相似的特点，但是，它们有以下根本的不同之处： 继承是把多种功能集中到了单个的对象中，它使类趋向于巨大化、全能化。相反地，转发是把职责进行了分化，它把一个问题分成了若干小的问题分配给不同的小对象，通过转发进行关联。 respondsToSelector:、instanceRespondToSelector和isKindOfClass:方法只看继承树，不看转发链，比如[aWarrior respondsToSelector:@selector(negotiate)]在这里为假，即使它能够接收negotiate的消息并且进行响应。如果使用了协议，那么conformsToProtocol:方法也在此列。但是你可以通过重写这些方法让他在转发中发挥和继承中一样的作用： 1234567891011- (BOOL)respondsToSelector:(SEL)aSelector&#123; if ( [super respondsToSelector:aSelector] ) return YES; else &#123; /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ &#125; return NO;&#125; 这个技巧只适合在没有其他可以使用的方法的情况下使用，它并不可以取代继承的作用。 代理对象转发不只只是模仿多继承，它尽可能地产生了更轻量化的对象去实现尽可能多的原本属于很多相关对象的特性。代理对象作为其他类的替身，把消息如实传递过去。代理对象更关注的是在向其他类的对象(远程对象)抓发消息这个过程的细节，比如确保在连接远程对象的过程中每个参数被正确传达等。但是它在这个过程中并不是把远程对象做了副本，而是创建了一个对应于远程对象的本地地址，通过这个地址，远程对象在其他应用可以收到这些转发的消息。还有一种情况，比如你有一个对象需要处理大批量的数据——创建一个复杂的图片或者从本地磁盘中读取文件等，这种情况下使用代理对象也是很合适的。创建一个这样的对象是很耗时的，所以我们希望只有在它确实需要或者在系统资源临时闲置的时候才回去创建它，但是又要保证存在这个对象的占位符使得其他对象涉及到这个对象的时候能够正常运行。在这种情况下，你可以在最开始的时候不要创建一个全功能的对象，而是创建一个代理对象给它。这个代理对象主要就是为即将创建的大型对象做一个占位，或是在时机成熟的时候，进行消息转发。当代理对象的forwardInvocation：方法第一次被调用的时候，它要确认代理的对象是不是存在了，如果还没有存在，就去创建它。在这个对象的其他功能被需要之前，代理对象和这个对象在意义上其实就是一样的。 参考：《Objective-C Runtime Programing Guide》 链接：《iOS必备技能之Runtime（一）》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS必备技能之Runtime（一）]]></title>
      <url>%2F2017%2F03%2F25%2FiOS%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8BRuntime%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Runtime 是一个比较底层的C语言的API，可以翻译为“运行时”。作为使用运行时机制的OC语言的底层，它在程序运行时把OC语言转换成了runtime的C语言代码。学习并理解runtime是OC学习历程中的不可或缺的一大块儿。 一、消息机制 调用方法的本质就是发送消息。 发送消息常见的有四个方法： objc_msgSend 向一个类的实例发送消息，返回id类型数据。（这也是最常用的一个发送消息的方法） objc_msgSend_stret 向一个类的实例发送消息，返回结构体类型数据。 objc_msgSendSuper 向一个类的实例的父类发送消息，返回id类型数据。 objc_msgSendSuper_stret 向一个类的实例的父类发送消息，返回结构体类型的数据。 在OC语言中，方法的真正实现是在程序运行的时候绑定的，假如一个方法只有声明，没有实现，调用后在编译阶段是不会出错的，真正报错是在运行的时候。 1[receiver message] 以上方法在运行时会被转化为1234//receiver是方法的调用者，selector是方法名objc_msgSend(receiver, selector)//如果有参数objc_msgSend(receiver, selector, arg1, arg2, ...) 发送消息的原理objc_msgSend为了完成动态绑定，进行了以下三步： 首先它要先根据方法名找到方法的具体实现程序，因为多态性，同一个方法在不同的类里面可以有不同的实现，所以查找主要依靠寻找receiver所在的类。 传递参数，调用该方法的实现程序。 把该程序的返回值作为方法自己的返回值。 1234567891011121314151617181920//runtime中对类的定义struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//runtime中对实例的定义struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 如上runtime中对类的定义，每一个类都有指向父类的指针(super_class)和一个方法调度表（objc_method_list **methodLists:根据方法名SEL查找该方法的具体实现的地址IMP），当向一个对象发送消息的时候，该对象通过isa指针找到该对象的类(实际上，实例的定义里面也只有这个指针，没有别的了)，在类的调度表查找该方法名，当找不到的时候，通过指向父类的指针找到该类的父类，然后在该类的父类中继续查找该方法名，这样递归查找一直到NSObject类为止(NSProxy类除外，它不属于NSObject子类)。如果查找到该方法名，根据调度表找到该方法的实现的地址进行调用。如下图所示 为了加速发送消息的进程，runtime系统会把使用过的方法名和对应的内存地址缓存起来，每个类都有一个单独的缓存空间，其中包含自己类的方法和继承自父类的方法。在查找调度表之前，runtime系统会首先在缓存中进行查找。 使用隐藏的参数当objc_msgSend找到方法的实现程序时，它调用这个程序并传递所有方法的参数给它，这其中还包含两个隐藏的参数： 消息的接收对象 调用方法的方法名（selector) 这两个参数虽然没有在方法中进行定义，但是你可以很方便地使用它们。消息的接收对象通过self来引用，方法名通过_cmd来引用。123456789- strange&#123; id target = getTheReceiver(); SEL method = getTheMethod(); if ( target == self || method == _cmd ) return nil; return [target performSelector:method];&#125; 获取方法的地址避免动态绑定的唯一方法就是直接获得方法的地址然后把它当做函数一样来调用。当一个方法被连续多次执行，而你又不想每次都用消息机制造成额外的开支，这种办法就是一个合适的使用时机。下面的例子展示了如何节省开支多次调用setFilled:方法1234567void (*setter)(id, SEL, BOOL);int i; setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 通过methodForSelector:方法，你可以请求得到指向实现该方法的程序的指针，然后通过这个指针调用该程序。值的注意的是，参数和返回值要正确声明，而且参数中id和SEL要进行显式声明。 二、动态方法假如你想动态地为方法提供实现，OC使用@dynamic实现了这个特性。1@dynamic propertyName; 这样就会通知编译器和这个属性相关的方法将会动态提供。你可以通过方法resolveInstanceMethod:和resolveClassMethod:分别为类方法和实例方法动态地提供实现。 一个OC的方法其实就是由C语言的函数再加上至少两个参数(self和_cmd)组成的。 你可以把一个函数通过class_addMethod作为方法添加到一个类中去。给定以下一个函数：123void dynamicMethodIMP(id self, SEL _cmd) &#123; // implementation ....&#125; 你可以通过resolveInstanceMethod:这个方法把上面的函数以方法名(resolveThisMethodDynamically)动态地添加到一个类(MyClass)里面。具体实现方式如下：12345678910@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:aSEL];&#125;@end 这其中，class_addMethod这个方法有四个参数，第一个是要添加方法的类，第二个是要添加的方法名，第三个是这个方法的实现函数的指针（值的注意的是，这个函数必须显式地把self和_cmd这两个参数写出来），第四个是方法的参数数组，在这里它是用的类型编码的方式进行表示的，因为方法一定含有self和_cmd这两个参数，所以字符数组的第二个和第三个字符一定是”@:”,第一个字符代表返回值，这里为空用“v”来表示。相关知识点请见下文。 三、类型编码为了使runtime系统更加简洁，编译器把每个方法的返回值和参数的类型都分别使用一个字符来编码，然后再把它们关联到方法选择器(selector)上。因为这种编码方案在其它环境中也很实用，所以我们可以很方便地使用@encode()编译器指令来自定义类似的编码。123char *buf1 = @encode(int **);char *buf2 = @encode(struct key);char *buf3 = @encode(Rectangle); 一般来说，不管是基本类型，还是指针，或者结构体，或者联合体，甚至可以是类名，只要这个类型能够作为C语言中sizeof()的参数，那么它就能被进行编码。 下表便是已经定义了的类型编码，使用@encode()编译器指令自定义编码的时候一定要避开这些字符。 特别注意，OC不支持long double类型，因此@encode(long double)会返回字符“d”，意义为double。结构体的类型编码是按照结构体内部的类型的顺序来表示的，比如12345typedef struct example &#123; id anObject; char *aString; int anInt;&#125; Example; 会被编码为：1&#123;example=@*i&#125; 由第一章内容可以得知，类的实例的定义是一个只包含isa指针的结构体，所以[NSObject class]会被编码为1&#123;NSObject=#&#125; 具体应用方面，上一章class_addMethod最后一个参数就是使用的类型编码来表示的函数返回值和参数的类型。 参考：《Objective-C Runtime Programing Guide》 链接：iOS必备技能之Runtime（二） 文章会不定期进行增添和更新，欢迎订阅和收藏！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac重装+初始化配置]]></title>
      <url>%2F2017%2F03%2F25%2FMac%E9%87%8D%E8%A3%85-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[MacBook使用时间长了之后难免会有很多杂七杂八的文件，存储空间严重不足，我一狠心，就趁着升级到10.12(macOS Sierra)系统的机会，把MacBook直接全部抹掉重装了。重装还不算麻烦，但是麻烦的就是在一清二白的系统上重新搭建起各种环境…… 一、重装系统据我所知的重装Mac系统的方法有三种： 通过Time Machine恢复 在线重装 自制U盘重装 具体的操作方式可以在网上查，本人懒一点，再加上网速还可以，就用了最省事的在线重装。 关闭MacBook，然后按住Commend + R不放，打开电源，直到出现苹果的标志，然后放开Commend + R。 这时候进入了OS X实用工具的界面，分别有“从Time Machine备份进行恢复“、”更新安装OS X“、”获得在线帮助“、”磁盘工具“这四类。 先进入”磁盘工具“，这时候左边能看到两个盘。上面的一个盘是自己的主存储盘，下属一个Macintosh HD子盘；下面的一个大概有2G左右的盘，就是类似于Windows PE系统的一个空间，不要去动它。选择Macintosh HD子盘，抹掉。 返回进入”更新安装OS X“选项，选择Macintosh HD子盘，进行在线安装。我安装的时候显示还有5分钟，可是我足足用了半个多小时才把这5分钟给跑完……然后就自动进行系统安装了。 剩下的就是配置Apple ID，以便于以后还原数据。 二、配置系统首先我就安装了Xcode 8.0，吃饭的家伙，必须要先保证有。然后安装了搜狗输入法、Clean My Mac、 有道词典、腾讯QQ、 印象笔记、 网易云音乐、 Dash、 Source Tree、 iStat Menus、 Snip、 The Unarchiver、 Xmind这几个软件，其他的以后想起来再安装。 值得注意的一点是，有些软件从App Store下载和从官方网站下载是完全不同的，App Store会对某些功能进行限制。比如；有道词典的划词和屏幕取词功能、网易云音乐的支持键盘顶部音乐控制功能，Snip的滚动截屏功能等。 升级ruby 从网上看到有因为ruby版本低而安装Cocoapods失败的，所以本着谨慎的原则，要先更新ruby。 更新ruby需要安装RVM，所以要先安装RVM。1curl -L https://get.rvm.io | bash -s stable 指定位置1source ~/.rvm/scripts/rvm 然后通过命令1rvm -v 查到我的RVM版本是1.27.0。 通过命令1ruby -v 查到我的ruby版本是2.0.0p648。然后通过命令1rvm list known 查到最新的版本是2.3.0。通过命令1rvm install 2.3.0 来安装在最新版本的ruby，但是它提示你没有安装Homebrew,输入路径进行安装，按回车键选择默认位置，然后一路回车，安装brew完毕，然后终端自动继续安装ruby 2.3.0，安装成功。 安装Cocoapods 通过命令1gem sources -l 查到系统默认的gem的源是https://rubygems.org/ ，这个在国内有被墙的危险，所以要改为国内的淘宝源。12gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/ 然后对gem进行更新1sudo gem update --system 更新后的版本为2.6.6。 终于到了要安装Cocoapods的时候了，由于Cocoapods的库文件太大，下载时间太长，可以从一台已经下载好了的电脑的~/目录里面把.cocoapods/文件夹拷贝到对应的位置，然后再下载库文件就省很多时间。但是系统默认是看不到隐藏文件夹的，可以通过命令1defaults write com.apple.finder AppleShowAllFiles -bool true 来使隐藏文件失效，必须重启finer才能生效。 通过命令1sudo gem install cocoapods 安装Cocoapods。 把从其它电脑复制得来的.cocoapods文件放到~/路径里面，然后终端运行1pod setup 在很短的时间内就安装好了。 安装LLDB命令插件chisel 在控制台输入以下命令 1brew install chisel 根据提示，在~/路径查找.lldbinit文件，发现没有，就新建一个该文件，并插入提示的文字。 123cd ~touch .lldbinitvi .lldbinit 在文件中粘贴command script import /usr/local/opt/chisel/libexec/fblldb.py这段话，并进行保存。 Safari插件配置 点击左上角Safari按钮 -&gt; Safari扩展… ，进入了一个插件库。先安装了Evernote Web Clipper，它可以很方便地把网页中的内容保存到自己的印象笔记账户里面去。 接着安装了Adblock Plus，拦截广告还是这个管用！ 因为苹果系统对Flash的不兼容，导致网页上的大部分视频都不能正常观看，看一小会儿就会发热很严重。在百度上搜索“妈妈再也不用担心我的macbook发烫了计划”，它能自动把网页上的Flash格式视频转换成HTML5格式的视频。把这个插件安装上，在进入优酷等对应网页的时候，就可以放心看视频了。 安全性和隐私里面添加“任何来源”在更新到10.12的系统后，发现在系统偏好设置-&gt;安全性和隐私-&gt;通用里面去掉了“任何来源“选项，导致没有签名的应用没办法安装，只允许AppStore和被认可的开发者的应用可以安装。在终端输入1sudo spctl --master-disable 命令，就可以重新看到”任何来源“了。 就先配置到这里，差不多可以用了，有啥添加的再看具体情况就可以了。]]></content>
    </entry>

    
  
  
</search>
